{"version":3,"file":"storage.worker-gd2jm-pM.js","sources":["../node_modules/idb/build/index.js","../src/services/secureStorage.ts","../src/workers/storage.worker.ts"],"sourcesContent":["const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst transactionDoneMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    // This mapping exists in reverseTransformCache but doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(this.request);\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n    get(target, prop) {\n        if (!advanceMethodProps.includes(prop))\n            return target[prop];\n        let cachedFunc = methodMap[prop];\n        if (!cachedFunc) {\n            cachedFunc = methodMap[prop] = function (...args) {\n                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n            };\n        }\n        return cachedFunc;\n    },\n};\nasync function* iterate(...args) {\n    // tslint:disable-next-line:no-this-assignment\n    let cursor = this;\n    if (!(cursor instanceof IDBCursor)) {\n        cursor = await cursor.openCursor(...args);\n    }\n    if (!cursor)\n        return;\n    cursor = cursor;\n    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n    // Map this double-proxy back to the original, so other cursor methods work.\n    reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n    while (cursor) {\n        yield proxiedCursor;\n        // If one of the advancing methods was not called, call continue().\n        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\n        advanceResults.delete(proxiedCursor);\n    }\n}\nfunction isIteratorProp(target, prop) {\n    return ((prop === Symbol.asyncIterator &&\n        instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) ||\n        (prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore])));\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get(target, prop, receiver) {\n        if (isIteratorProp(target, prop))\n            return iterate;\n        return oldTraps.get(target, prop, receiver);\n    },\n    has(target, prop) {\n        return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n    },\n}));\n\nexport { deleteDB, openDB, unwrap, wrap };\n","/* eslint-disable max-lines */\nimport * as logger from '../utils/logger';\n\n/**\n * SecureStorage - Encrypted localStorage wrapper\n * V2 Architecture: Master Key (MK) Encryption\n * - Data is encrypted with a random Master Key (MK).\n * - MK is encrypted (wrapped) with a KDF derived from PIN + WebAuthn Secret.\n * - This file manages the active MK and encryption ops.\n */\n\nlet _activeMasterKey: CryptoKey | null = null;\n// let _encryptionLock = false; // Unused\n\n// We still need to track if we have a key loaded\nlet _isKeyLoaded = false;\n\n/**\n * Storage Format V2:\n * {\n *   version: 2,\n *   encrypted: string (base64 ciphertext),\n *   iv: string (base64 iv),\n *   tag: string (base64 tag),\n *   salt: string (base64 salt - used for diversification if needed, or strictly random)\n * }\n */\n\n/**\n * Set the Master Key for the current session.\n * Called after unwrapping the key during login/unlock.\n */\nexport function setMasterKey(key: CryptoKey | null) {\n  _activeMasterKey = key;\n  _isKeyLoaded = !!key;\n  if (!key) {\n    logger.debug('[SecureStorage] Master Key cleared');\n  } else {\n    logger.debug('[SecureStorage] Master Key set');\n  }\n}\n\nexport function getMasterKey(): CryptoKey | null {\n  return _activeMasterKey;\n}\n\n/**\n * Generate a new random Master Key (AES-GCM 256)\n */\nexport async function generateMasterKey(): Promise<CryptoKey> {\n  return await crypto.subtle.generateKey(\n    {\n      name: 'AES-GCM',\n      length: 256,\n    },\n    true, // Extractable (must be able to wrap it)\n    ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey'],\n  );\n}\n\n/**\n * Derive a Record Key using HKDF (SHA-256)\n * Output = HKDF(MasterKey, Salt, Info=\"RecordEncryption\")\n */\nasync function deriveRecordKey(masterKey: CryptoKey, salt: Uint8Array): Promise<CryptoKey> {\n  const mkRaw = await crypto.subtle.exportKey('raw', masterKey);\n  const mkKeyMaterial = await crypto.subtle.importKey('raw', mkRaw, 'HKDF', false, ['deriveKey']);\n\n  return await crypto.subtle.deriveKey(\n    {\n      name: 'HKDF',\n      hash: 'SHA-256',\n      salt: salt,\n      info: new TextEncoder().encode('RecordEncryption'),\n    },\n    mkKeyMaterial,\n    { name: 'AES-GCM', length: 256 },\n    false,\n    ['encrypt', 'decrypt'],\n  );\n}\n\n/**\n * Encrypt data using the currently loaded Master Key (Version 2)\n */\n/**\n * Pure Encryption Utility (Worker Compatible)\n */\nexport async function encryptWithKey(data: string, key: CryptoKey): Promise<string> {\n  const iv = crypto.getRandomValues(new Uint8Array(12));\n\n  // V2.2: Mandatory random salt for future key diversification\n  const salt = crypto.getRandomValues(new Uint8Array(16));\n\n  // V2.2: Derive Per-Record Key\n  const recordKey = await deriveRecordKey(key, salt);\n\n  const encoder = new TextEncoder();\n  const encrypted = await crypto.subtle.encrypt(\n    {\n      name: 'AES-GCM',\n      iv: iv,\n    },\n    recordKey,\n    encoder.encode(data),\n  );\n\n  const encryptedArray = new Uint8Array(encrypted);\n  // Separate tag (last 16 bytes)\n  const ciphertext = encryptedArray.slice(0, -16);\n  const tag = encryptedArray.slice(-16);\n\n  const uint8ArrayToBase64 = (bytes: Uint8Array): string => {\n    let binary = '';\n    const len = bytes.byteLength;\n    const CHUNK_SIZE = 0x8000;\n    for (let i = 0; i < len; i += CHUNK_SIZE) {\n      const chunk = bytes.subarray(i, Math.min(i + CHUNK_SIZE, len));\n      binary += String.fromCharCode.apply(null, Array.from(chunk));\n    }\n    return btoa(binary);\n  };\n\n  const obj = {\n    version: 2,\n    encrypted: uint8ArrayToBase64(ciphertext),\n    iv: btoa(String.fromCharCode(...iv)),\n    tag: btoa(String.fromCharCode(...tag)),\n    salt: btoa(String.fromCharCode(...salt)), // Stored for future diversification\n  };\n\n  return JSON.stringify(obj);\n}\n\n/**\n * Encrypt data using the currently loaded Master Key (Version 2)\n */\nexport async function encryptData(\n  data: string,\n  _legacyPassphraseIgnored?: string,\n): Promise<string> {\n  if (!_activeMasterKey) {\n    throw new Error('Master Key not loaded - cannot encrypt');\n  }\n  return encryptWithKey(data, _activeMasterKey);\n}\n\n/**\n * Decrypt data using the Master Key (Strict V2)\n */\nexport async function decryptData(\n  encryptedData: string,\n  _legacyPassphraseIgnored?: string,\n): Promise<string> {\n  if (!_activeMasterKey) {\n    throw new Error('Master Key not loaded - cannot decrypt');\n  }\n  return decryptWithKey(encryptedData, _activeMasterKey);\n}\n\n/**\n * Pure Decryption Utility (Worker Compatible)\n */\n// eslint-disable-next-line max-lines-per-function\nexport async function decryptWithKey(encryptedData: string, key: CryptoKey): Promise<string> {\n  const obj = JSON.parse(encryptedData);\n\n  if (obj.version !== 2) {\n    throw new Error(`Unsupported encryption version: ${obj.version}. Migration required.`);\n  }\n\n  // Optimized Base64 Decoding\n  const fromBase64 = (base64: string): Uint8Array => {\n    const binaryString = atob(base64);\n    const len = binaryString.length;\n    const bytes = new Uint8Array(len);\n    for (let i = 0; i < len; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes;\n  };\n\n  const iv = fromBase64(obj.iv);\n  const ciphertext = fromBase64(obj.encrypted);\n  const tag = fromBase64(obj.tag);\n  const salt = obj.salt ? fromBase64(obj.salt) : new Uint8Array(0);\n\n  // V2.2: Re-derive Record Key if salt is present\n  // If no salt (legacy V2.0/2.1), fallback to Master Key (Backward Compat if needed, but we are resetting DB)\n  // Since we are resetting DB, we enforce salt presence.\n  if (salt.length !== 16) {\n    throw new Error('Invalid or missing salt in V2.2 record');\n  }\n\n  const recordKey = await deriveRecordKey(key, salt);\n\n  const encryptedWithTag = new Uint8Array(ciphertext.length + tag.length);\n  encryptedWithTag.set(ciphertext, 0);\n  encryptedWithTag.set(tag, ciphertext.length);\n\n  try {\n    const decrypted = await crypto.subtle.decrypt(\n      {\n        name: 'AES-GCM',\n        iv: iv,\n      },\n      recordKey,\n      encryptedWithTag,\n    );\n\n    return new TextDecoder().decode(decrypted);\n  } catch (_) {\n    throw new Error('Decryption failed');\n  }\n}\n\n/**\n * KEY WRAPPING UTILITIES (For System Settings)\n */\n\n// Worker instance for auth operations\nlet _authWorker: Worker | null = null;\nconst _pendingAuthRequests = new Map<\n  string,\n  { resolve: (value: unknown) => void; reject: (reason: unknown) => void }\n>();\n\nfunction getAuthWorker(): Worker {\n  if (!_authWorker) {\n    _authWorker = new Worker(new URL('../workers/auth.worker.ts', import.meta.url), {\n      type: 'module',\n    });\n    _authWorker.onmessage = (event) => {\n      const { id, success, data, error } = event.data;\n      const request = _pendingAuthRequests.get(id);\n      if (request) {\n        _pendingAuthRequests.delete(id);\n        if (success) {\n          request.resolve(data);\n        } else {\n          request.reject(new Error(error));\n        }\n      }\n    };\n  }\n  return _authWorker;\n}\n\n/**\n * Helper to manage dynamic salt\n */\nfunction getOrGenerateSalt(): Uint8Array {\n  // Worker Guard: Workers should not call this, but if imported, ensure we don't crash on parse\n  if (typeof localStorage === 'undefined') {\n    throw new Error('localStorage not available (Worker context?)');\n  }\n\n  const SALT_KEY = 'nahan_wrapper_salt';\n  let saltBase64 = localStorage.getItem(SALT_KEY);\n\n  if (!saltBase64) {\n    // Generate 16-byte random salt\n    const randomSalt = crypto.getRandomValues(new Uint8Array(16));\n    // Convert to base64 for storage\n    const binary = String.fromCharCode.apply(null, Array.from(randomSalt));\n    saltBase64 = btoa(binary);\n    localStorage.setItem(SALT_KEY, saltBase64);\n    logger.debug('[SecureStorage] Generated new dynamic wrapper salt');\n  }\n\n  return Uint8Array.from(atob(saltBase64), (c) => c.charCodeAt(0));\n}\n\n/**\n * Derive a Key-Wrapping Key (KWK) from PIN + Hardware Secret\n * using PBKDF2 in a WORKER\n */\nasync function deriveWrapperKey(pin: string, hardwareSecret: Uint8Array): Promise<CryptoKey> {\n  const salt = getOrGenerateSalt();\n  const worker = getAuthWorker();\n\n  return new Promise((resolve, reject) => {\n    const id = crypto.randomUUID();\n    _pendingAuthRequests.set(id, {\n      resolve: async (jwk: JsonWebKey) => {\n        // Import the JWK back to a CryptoKey on the main thread\n        try {\n          const key = await crypto.subtle.importKey(\n            'jwk',\n            jwk,\n            { name: 'AES-KW', length: 256 },\n            false,\n            ['wrapKey', 'unwrapKey'],\n          );\n          resolve(key);\n        } catch (e) {\n          reject(e);\n        }\n      },\n      reject,\n    });\n\n    worker.postMessage({\n      id,\n      type: 'deriveWrapperKey',\n      payload: {\n        pin,\n        hardwareSecret,\n        salt,\n      },\n    });\n  });\n}\n\n/**\n * Generate a Blind Index for metadata obfuscation\n * Uses HMAC-SHA256(MasterKey, input)\n */\nexport async function generateBlindIndex(input: string): Promise<string> {\n  if (!_activeMasterKey) {\n    throw new Error('Master Key not loaded - cannot generate blind index');\n  }\n\n  try {\n    // 1. Export Master Key raw bytes\n    const mkRaw = await crypto.subtle.exportKey('raw', _activeMasterKey);\n\n    // 2. Import as HMAC key\n    const hmacKey = await crypto.subtle.importKey(\n      'raw',\n      mkRaw,\n      { name: 'HMAC', hash: 'SHA-256' },\n      false,\n      ['sign'],\n    );\n\n    // 3. Sign the input\n    const encoder = new TextEncoder();\n    const signature = await crypto.subtle.sign('HMAC', hmacKey, encoder.encode(input));\n\n    // 4. Return as hex string\n    return Array.from(new Uint8Array(signature))\n      .map((b) => b.toString(16).padStart(2, '0'))\n      .join('');\n  } catch (error) {\n    logger.error('Failed to generate blind index:', error);\n    throw new Error('Blind indexing failed');\n  }\n}\n\n/**\n * Wrap the Master Key for storage\n */\nexport async function wrapMasterKey(\n  masterKey: CryptoKey,\n  pin: string,\n  hardwareSecret: Uint8Array,\n): Promise<string> {\n  const wrapperKey = await deriveWrapperKey(pin, hardwareSecret);\n\n  const wrappedIndex = await crypto.subtle.wrapKey('raw', masterKey, wrapperKey, 'AES-KW');\n\n  return btoa(String.fromCharCode(...new Uint8Array(wrappedIndex)));\n}\n\n/**\n * Unwrap the Master Key from storage\n */\nexport async function unwrapMasterKey(\n  wrappedKeyBase64: string,\n  pin: string,\n  hardwareSecret: Uint8Array,\n): Promise<CryptoKey> {\n  const wrapperKey = await deriveWrapperKey(pin, hardwareSecret);\n  const wrappedKey = Uint8Array.from(atob(wrappedKeyBase64), (c) => c.charCodeAt(0));\n\n  return await crypto.subtle.unwrapKey(\n    'raw',\n    wrappedKey,\n    wrapperKey,\n    'AES-KW',\n    { name: 'AES-GCM', length: 256 },\n    true,\n    ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey'],\n  );\n}\n\n// --------------------------------------------------------------------------\n// LEGACY HELPERS (TEMPORARY FOR MIGRATION)\n// --------------------------------------------------------------------------\n\n/**\n * Legacy V1 Decryption (PIN only)\n * Kept strictly for the one-time migration process.\n */\nexport async function decryptLegacyData(\n  encryptedData: string,\n  passphrase: string,\n): Promise<string> {\n  // Copy of the old derived key logic\n  const deriveLegacyKey = async (passphrase: string, salt: Uint8Array) => {\n    const encoder = new TextEncoder();\n    const keyMaterial = await crypto.subtle.importKey(\n      'raw',\n      encoder.encode(passphrase),\n      'PBKDF2',\n      false,\n      ['deriveKey'],\n    );\n    return await crypto.subtle.deriveKey(\n      { name: 'PBKDF2', salt, iterations: 600000, hash: 'SHA-256' },\n      keyMaterial,\n      { name: 'AES-GCM', length: 256 },\n      false,\n      ['decrypt'],\n    );\n  };\n\n  try {\n    const obj = JSON.parse(encryptedData);\n    // If it's already V2, this function fails (intended)\n    if (obj.version && obj.version !== 1) throw new Error('Not V1 data');\n\n    const salt = Uint8Array.from(atob(obj.salt), (c) => c.charCodeAt(0));\n    const iv = Uint8Array.from(atob(obj.iv), (c) => c.charCodeAt(0));\n    const ciphertext = Uint8Array.from(atob(obj.encrypted), (c) => c.charCodeAt(0));\n    const tag = Uint8Array.from(atob(obj.tag), (c) => c.charCodeAt(0));\n\n    const key = await deriveLegacyKey(passphrase, salt);\n\n    const combined = new Uint8Array(ciphertext.length + tag.length);\n    combined.set(ciphertext, 0);\n    combined.set(tag, ciphertext.length);\n\n    const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, combined);\n\n    return new TextDecoder().decode(decrypted);\n  } catch (_e) {\n    throw new Error('Legacy decryption failed');\n  }\n}\n\n// --------------------------------------------------------------------------\n// ZUSTAND WRAPPER\n// --------------------------------------------------------------------------\n\nexport const secureStorage = {\n  getItem: (name: string): string | null => {\n    return localStorage.getItem(name);\n  },\n\n  setItem: (name: string, value: string): Promise<void> => {\n    if (!_activeMasterKey) {\n      logger.debug('SecureStorage: Save aborted - Master Key not loaded');\n      return Promise.resolve();\n    }\n\n    try {\n      const parsed = JSON.parse(value);\n      if (parsed.version === 2) {\n        localStorage.setItem(name, value);\n        return Promise.resolve();\n      }\n    } catch {\n      // Not encrypted\n    }\n\n    // Encrypt async and return promise so Zustand can await it\n    return encryptData(value).then((encrypted) => {\n      localStorage.setItem(name, encrypted);\n    });\n  },\n\n  removeItem: (name: string): void => {\n    localStorage.removeItem(name);\n  },\n};\n\n// Re-export specific functions for direct usage\nexport function setPassphrase(_p: string | null) {\n  // Legacy compatibility: Does nothing in V2 mode as we use setMasterKey\n  // But we might want to warn if used\n}\n\nexport function clearKeyCache() {\n  setMasterKey(null);\n}\n","\nimport { IDBPDatabase, openDB } from 'idb';\nimport { decryptWithKey, encryptWithKey } from '../services/secureStorage';\n\nconst ctx: Worker = self as unknown as Worker;\n\nlet db: IDBPDatabase | null = null;\nconst DB_NAME = 'nahan';\nconst DB_VERSION = 4;\nconst ID_PREFIX_MESSAGE = 'idx_';\n\ninterface WorkerRequest {\n  id: string;\n  type: 'getMessages' | 'storeMessage';\n  payload: {\n    // Shared\n    masterKey: CryptoKey;\n\n    // getMessages\n    fingerprint?: string;\n    limit?: number;\n    offset?: number;\n\n    // storeMessage\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    message?: any; // We'll keep it loose or import types if possible\n  };\n}\n\n// Optimized Base64 to Blob conversion\nconst base64ToBlob = (base64: string, type = 'image/png'): Blob => {\n  const binary = atob(base64.split(',')[1] || base64);\n  const array = new Uint8Array(binary.length);\n  for (let i = 0; i < binary.length; i++) {\n    array[i] = binary.charCodeAt(i);\n  }\n  return new Blob([array], { type });\n};\n\nconst initializeDB = async () => {\n  if (!db) {\n    db = await openDB(DB_NAME, DB_VERSION);\n  }\n  return db;\n};\n\nconst generateBlindIndexWithKey = async (input: string, masterKey: CryptoKey): Promise<string> => {\n  const mkRaw = await crypto.subtle.exportKey('raw', masterKey);\n\n  const hmacKey = await crypto.subtle.importKey(\n    'raw',\n    mkRaw,\n    { name: 'HMAC', hash: 'SHA-256' },\n    false,\n    ['sign'],\n  );\n\n  const signature = await crypto.subtle.sign(\n    'HMAC',\n    hmacKey,\n    new TextEncoder().encode(input),\n  );\n\n  return Array.from(new Uint8Array(signature))\n    .map((b) => b.toString(16).padStart(2, '0'))\n    .join('');\n};\n\n// eslint-disable-next-line max-lines-per-function\nconst handleGetMessages = async (payload: WorkerRequest['payload']) => {\n  const start = performance.now();\n  const { fingerprint, limit, offset, masterKey } = payload;\n  const db = await initializeDB();\n\n  const blindIndex = await generateBlindIndexWithKey(fingerprint as string, masterKey);\n  const prefix = `${ID_PREFIX_MESSAGE}${blindIndex}_`;\n  const range = IDBKeyRange.bound(prefix, prefix + '\\uffff', false, false);\n\n  const tx = db.transaction('secure_vault', 'readonly');\n  const store = tx.objectStore('secure_vault');\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const rawEntries: any[] = [];\n\n  const cursorStart = performance.now();\n  let cursor = await store.openCursor(range, 'prev');\n  if (offset > 0 && cursor) await cursor.advance(offset);\n\n  let scannedCount = 0;\n  while (cursor && rawEntries.length < limit) {\n     scannedCount++;\n     // Double check prefix (bound should handle it, but for safety/perf check)\n     if (cursor.value.id.startsWith(prefix)) {\n       rawEntries.push(cursor.value);\n     }\n     cursor = await cursor.continue();\n  }\n  const scanDuration = performance.now() - cursorStart;\n\n  // Parallel Decryption & Image Processing\n  const decryptStart = performance.now();\n  const results = await Promise.all(\n    rawEntries.map(async (entry) => {\n      try {\n        const json = await decryptWithKey(entry.payload, masterKey);\n        const msg = JSON.parse(json);\n\n        // Convert base64 image to Blob\n        // We replace the string with the Blob object.\n        // The main thread will create the URL.\n        if (msg.content && msg.content.image && msg.content.image.startsWith('data:')) {\n           msg.content.imageBlob = base64ToBlob(msg.content.image);\n           delete msg.content.image; // Remove base64 to save memory transfer\n        }\n\n        // Strict isolation check\n        if (msg.recipientFingerprint === fingerprint || msg.senderFingerprint === fingerprint) {\n           // Restore Dates\n           if (msg.createdAt) msg.createdAt = new Date(msg.createdAt);\n           return msg;\n        }\n      } catch (_e) {\n        // console.warn('Worker decryption failed', e);\n      }\n      return null;\n    })\n  );\n  const decryptDuration = performance.now() - decryptStart;\n\n  // eslint-disable-next-line no-console\n  console.log(`[PERF][Worker] getMessages('${fingerprint}') - Scan: ${scanDuration.toFixed(2)}ms (${scannedCount} items), Decrypt: ${decryptDuration.toFixed(2)}ms, Total: ${(performance.now() - start).toFixed(2)}ms`);\n\n  return results.filter(Boolean).sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());\n};\n\nconst handleStoreMessage = async (payload: WorkerRequest['payload']) => {\n  const { message, masterKey } = payload;\n  const db = await initializeDB();\n\n  // Encrypt the message using the passed Master Key (pure worker logic)\n  // We use encryptWithKey which we must import from secureStorage\n  // Note: encryptWithKey must be available. We added it to secureStorage.ts.\n  const encryptedPayload = await encryptWithKey(JSON.stringify(message), masterKey);\n\n  const entry = {\n    id: message.id,\n    payload: encryptedPayload,\n  };\n\n  const tx = db.transaction('secure_vault', 'readwrite');\n  await tx.objectStore('secure_vault').put(entry);\n  await tx.done;\n\n  return message;\n};\n\nctx.onmessage = async (event: MessageEvent) => {\n  const { id, type, payload } = event.data as WorkerRequest;\n\n  try {\n    if (type === 'getMessages') {\n      const result = await handleGetMessages(payload);\n      ctx.postMessage({ id, success: true, data: result });\n    } else if (type === 'storeMessage') {\n      const result = await handleStoreMessage(payload);\n      ctx.postMessage({ id, success: true, data: result });\n    }\n  } catch (error) {\n    ctx.postMessage({ id, success: false, error: (error as Error).message });\n  }\n};\n\nexport { };\n\n"],"names":["instanceOfAny","object","constructors","c","idbProxyableTypes","cursorAdvanceMethods","getIdbProxyableTypes","getCursorAdvanceMethods","transactionDoneMap","transformCache","reverseTransformCache","promisifyRequest","request","promise","resolve","reject","unlisten","success","error","wrap","cacheDonePromiseForTransaction","tx","done","complete","idbProxyTraps","target","prop","receiver","value","replaceTraps","callback","wrapFunction","func","args","unwrap","transformCachableValue","newValue","openDB","name","version","blocked","upgrade","blocking","terminated","openPromise","event","db","readMethods","writeMethods","cachedMethods","getMethod","targetFuncName","useIndex","isWrite","method","storeName","oldTraps","advanceMethodProps","methodMap","advanceResults","ittrProxiedCursorToOriginalProxy","cursorIteratorTraps","cachedFunc","iterate","cursor","proxiedCursor","isIteratorProp","deriveRecordKey","masterKey","salt","mkRaw","mkKeyMaterial","encryptWithKey","data","key","iv","recordKey","encoder","encrypted","encryptedArray","ciphertext","tag","obj","bytes","binary","len","CHUNK_SIZE","i","chunk","decryptWithKey","encryptedData","fromBase64","base64","binaryString","encryptedWithTag","decrypted","ctx","DB_NAME","DB_VERSION","ID_PREFIX_MESSAGE","base64ToBlob","type","array","initializeDB","generateBlindIndexWithKey","input","hmacKey","signature","b","handleGetMessages","payload","start","fingerprint","limit","offset","blindIndex","prefix","range","store","rawEntries","cursorStart","scannedCount","scanDuration","decryptStart","results","entry","json","msg","decryptDuration","a","handleStoreMessage","message","encryptedPayload","id","result"],"mappings":"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","x_google_ignoreList":[0]}