(function(){"use strict";const D=(e,t)=>t.some(n=>e instanceof n);let P,T;function K(){return P||(P=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function N(){return T||(T=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const I=new WeakMap,B=new WeakMap,w=new WeakMap;function V(e){const t=new Promise((n,o)=>{const r=()=>{e.removeEventListener("success",a),e.removeEventListener("error",s)},a=()=>{n(h(e.result)),r()},s=()=>{o(e.error),r()};e.addEventListener("success",a),e.addEventListener("error",s)});return w.set(t,e),t}function $(e){if(I.has(e))return;const t=new Promise((n,o)=>{const r=()=>{e.removeEventListener("complete",a),e.removeEventListener("error",s),e.removeEventListener("abort",s)},a=()=>{n(),r()},s=()=>{o(e.error||new DOMException("AbortError","AbortError")),r()};e.addEventListener("complete",a),e.addEventListener("error",s),e.addEventListener("abort",s)});I.set(e,t)}let E={get(e,t,n){if(e instanceof IDBTransaction){if(t==="done")return I.get(e);if(t==="store")return n.objectStoreNames[1]?void 0:n.objectStore(n.objectStoreNames[0])}return h(e[t])},set(e,t,n){return e[t]=n,!0},has(e,t){return e instanceof IDBTransaction&&(t==="done"||t==="store")?!0:t in e}};function L(e){E=e(E)}function R(e){return N().includes(e)?function(...t){return e.apply(M(this),t),h(this.request)}:function(...t){return h(e.apply(M(this),t))}}function U(e){return typeof e=="function"?R(e):(e instanceof IDBTransaction&&$(e),D(e,K())?new Proxy(e,E):e)}function h(e){if(e instanceof IDBRequest)return V(e);if(B.has(e))return B.get(e);const t=U(e);return t!==e&&(B.set(e,t),w.set(t,e)),t}const M=e=>w.get(e);function k(e,t,{blocked:n,upgrade:o,blocking:r,terminated:a}={}){const s=indexedDB.open(e,t),i=h(s);return o&&s.addEventListener("upgradeneeded",c=>{o(h(s.result),c.oldVersion,c.newVersion,h(s.transaction),c)}),n&&s.addEventListener("blocked",c=>n(c.oldVersion,c.newVersion,c)),i.then(c=>{a&&c.addEventListener("close",()=>a()),r&&c.addEventListener("versionchange",u=>r(u.oldVersion,u.newVersion,u))}).catch(()=>{}),i}const G=["get","getKey","getAll","getAllKeys","count"],J=["put","add","delete","clear"],S=new Map;function _(e,t){if(!(e instanceof IDBDatabase&&!(t in e)&&typeof t=="string"))return;if(S.get(t))return S.get(t);const n=t.replace(/FromIndex$/,""),o=t!==n,r=J.includes(n);if(!(n in(o?IDBIndex:IDBObjectStore).prototype)||!(r||G.includes(n)))return;const a=async function(s,...i){const c=this.transaction(s,r?"readwrite":"readonly");let u=c.store;return o&&(u=u.index(i.shift())),(await Promise.all([u[n](...i),r&&c.done]))[0]};return S.set(t,a),a}L(e=>({...e,get:(t,n,o)=>_(t,n)||e.get(t,n,o),has:(t,n)=>!!_(t,n)||e.has(t,n)}));const z=["continue","continuePrimaryKey","advance"],j={},A=new WeakMap,F=new WeakMap,H={get(e,t){if(!z.includes(t))return e[t];let n=j[t];return n||(n=j[t]=function(...o){A.set(this,F.get(this)[t](...o))}),n}};async function*X(...e){let t=this;if(t instanceof IDBCursor||(t=await t.openCursor(...e)),!t)return;t=t;const n=new Proxy(t,H);for(F.set(n,t),w.set(n,M(t));t;)yield n,t=await(A.get(n)||t.continue()),A.delete(n)}function O(e,t){return t===Symbol.asyncIterator&&D(e,[IDBIndex,IDBObjectStore,IDBCursor])||t==="iterate"&&D(e,[IDBIndex,IDBObjectStore])}L(e=>({...e,get(t,n,o){return O(t,n)?X:e.get(t,n,o)},has(t,n){return O(t,n)||e.has(t,n)}}));async function Z(e,t){const n=crypto.getRandomValues(new Uint8Array(12)),o=new TextEncoder,r=await crypto.subtle.encrypt({name:"AES-GCM",iv:n},t,o.encode(e)),a=new Uint8Array(r),s=a.slice(0,-16),i=a.slice(-16),u={version:2,encrypted:(g=>{let l="";const y=g.byteLength,f=32768;for(let m=0;m<y;m+=f){const v=g.subarray(m,Math.min(m+f,y));l+=String.fromCharCode.apply(null,Array.from(v))}return btoa(l)})(s),iv:btoa(String.fromCharCode(...n)),tag:btoa(String.fromCharCode(...i)),salt:""};return JSON.stringify(u)}async function Q(e,t){const n=JSON.parse(e);if(n.version!==2)throw new Error(`Unsupported encryption version: ${n.version}. Migration required.`);const o=c=>{const u=atob(c),g=u.length,l=new Uint8Array(g);for(let y=0;y<g;y++)l[y]=u.charCodeAt(y);return l},r=o(n.iv),a=o(n.encrypted),s=o(n.tag),i=new Uint8Array(a.length+s.length);i.set(a,0),i.set(s,a.length);try{const c=await crypto.subtle.decrypt({name:"AES-GCM",iv:r},t,i);return new TextDecoder().decode(c)}catch{throw new Error("Decryption failed")}}const p=self;let C=null;const Y="nahan_secure_v1",q=3,ee="msg_",te=(e,t="image/png")=>{const n=atob(e.split(",")[1]||e),o=new Uint8Array(n.length);for(let r=0;r<n.length;r++)o[r]=n.charCodeAt(r);return new Blob([o],{type:t})},W=async()=>(C||(C=await k(Y,q)),C),ne=async e=>{const t=performance.now(),{fingerprint:n,limit:o,offset:r,masterKey:a}=e,s=await W(),i=`${ee}${n}_`,c=IDBKeyRange.bound(i,i+"ï¿¿",!1,!1),g=s.transaction("secure_vault","readonly").objectStore("secure_vault"),l=[],y=performance.now();let f=await g.openCursor(c,"prev");r>0&&f&&await f.advance(r);let m=0;for(;f&&l.length<o;)m++,f.value.id.startsWith(i)&&l.push(f.value),f=await f.continue();const v=performance.now()-y,oe=performance.now(),se=await Promise.all(l.map(async x=>{try{const b=await Q(x.payload,a),d=JSON.parse(b);if(d.content&&d.content.image&&d.content.image.startsWith("data:")&&(d.content.imageBlob=te(d.content.image),delete d.content.image),d.recipientFingerprint===n||d.senderFingerprint===n)return d.createdAt&&(d.createdAt=new Date(d.createdAt)),d}catch{}return null})),ae=performance.now()-oe;return console.log(`[PERF][Worker] getMessages('${n}') - Scan: ${v.toFixed(2)}ms (${m} items), Decrypt: ${ae.toFixed(2)}ms, Total: ${(performance.now()-t).toFixed(2)}ms`),se.filter(Boolean).sort((x,b)=>b.createdAt.getTime()-x.createdAt.getTime())},re=async e=>{const{message:t,masterKey:n}=e,o=await W(),r=await Z(JSON.stringify(t),n),a={id:t.id,payload:r},s=o.transaction("secure_vault","readwrite");return await s.objectStore("secure_vault").put(a),await s.done,t};p.onmessage=async e=>{const{id:t,type:n,payload:o}=e.data;try{if(n==="getMessages"){const r=await ne(o);p.postMessage({id:t,success:!0,data:r})}else if(n==="storeMessage"){const r=await re(o);p.postMessage({id:t,success:!0,data:r})}}catch(r){p.postMessage({id:t,success:!1,error:r.message})}}})();
